
- [fmt](#fmt)
  - [fmt介绍](#fmt介绍)
  - [输出](#输出)
    - [Print](#print)
    - [Fprint](#fprint)
    - [Sprint](#sprint)
    - [Errorf](#errorf)
  - [格式化占位符](#格式化占位符)
    - [通用占位符](#通用占位符)
    - [布尔型](#布尔型)
    - [整型](#整型)
    - [浮点数与复数](#浮点数与复数)
    - [字符串和\[\]byte](#字符串和byte)
    - [指针](#指针)
    - [宽度标识符](#宽度标识符)
    - [其他flag](#其他flag)
  - [获取输入](#获取输入)
    - [Scan](#scan)
    - [Scanln(未理解)](#scanln未理解)
    - [Scanf](#scanf)
    - [使用 bufio 包获取输入](#使用-bufio-包获取输入)
    - [使用 Fscan 函数](#使用-fscan-函数)
    - [使用 Sscan 函数](#使用-sscan-函数)
- [io](#io)
  - [Reader](#reader)
- [io.Writer](#iowriter)
- [io.Closer](#iocloser)
- [io.Seeker](#ioseeker)
- [os](#os)

## fmt

### fmt介绍

fmt 用于格式化输入和输出数据。这个库的名称 "fmt" 来自于 "format"，因为它主要用于格式化数据。

fmt 包的主要功能包括：

1. **格式化输出**：fmt 包提供了函数如 `Print`, `Printf`, `Println`, `Fprint`, `Fprintf`, 和 `Fprintln` 用于将数据输出到标准输出或指定的 io.Writer。你可以使用这些函数将数据以不同的格式打印到屏幕上或文件中。
2. **格式化输入**：fmt 包也支持从输入源（通常是标准输入）读取数据，并根据格式规范解析数据。这是通过 `Scan`, `Scanf`, 和 `Scanln` 函数实现的。这对于从用户获取输入数据非常有用。
3. **字符串格式化**：你可以使用 `Sprintf` 函数将数据格式化为字符串而不是直接输出到标准输出，这对于构建日志消息或其他需要格式化的字符串很有用。
4. **错误格式化**：fmt 包也提供了 `Errorf` 函数，用于将格式化的错误消息作为 error 类型返回，方便错误处理。
5. **格式化占位符**：在格式化字符串中，你可以使用占位符来指定如何格式化数据。常见的占位符包括 `%d`（整数），`%f`（浮点数），`%s`（字符串）等。

### 输出

#### Print

- `Print`：接受任意数量的参数，并将它们串联成一个字符串输出，不会添加换行符。
- `Printf`：格式化输出，根据格式化字符串的占位符将参数格式化并输出。
- `Println`：类似于 `Print`，但会在**输出后自动添加一个换行符**。

```go
func Print(a ...interface{}) (n int, err error) 
func Printf(format string, a ...interface{}) (n int, err error) 
func Println(a ...interface{}) (n int, err error)
```

例子：

```go
func main() { 
    fmt.Print("Hello, ", "world") 
    name := "Alice" 
    age := 30 
    fmt.Printf("Hello, %s. You are %d years old.\n", name, age) 
    fmt.Println("Hello, world") 
    }
```

#### Fprint

`Fprint` 用于将文本输出到指定的 `io.Writer` 接口，而不仅仅是标准输出。你可以将文本输出到文件、网络连接等。这些函数的参数列表包括一个 `io.Writer` 参数，以及任意数量的参数。

```go
func Fprint(w io.Writer, a ...interface{}) (n int, err error) 
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) 
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
```

举个例子：

```go
func main() { 
    // 向标准输出写入内容 
    fmt.Fprintln(os.Stdout, "向标准输出写入内容") 
    fileObj, err := os.OpenFile("./output.txt", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644) 
    if err != nil { 
        fmt.Println("打开文件出错，err:", err) 
        return 
        } 
        name := "jarvis" // 向打开的文件句柄中写入内容 
        fmt.Fprintf(fileObj, "往文件中写如信息：%s", name) 
        }
```

这个示例创建了一个名为 "output.txt" 的文件，并将数据写入文件中。

#### Sprint

`Sprint` 用于将文本输出到字符串中，而不是标准输出或文件。它们将文本格式化为字符串并返回结果。

```go
func Sprint(a ...interface{}) string 
func Sprintf(format string, a ...interface{}) string 
func Sprintln(a ...interface{}) string
```

简单的示例代码如下：

```go
func main() { 
    s1 := fmt.Sprint("jarvis") 
    name := "jarvis" 
    age := 18 
    s2 := fmt.Sprintf("name:%s,age:%d", name, age) 
    s3 := fmt.Sprintln("jarvis") 
    fmt.Println(s1, s2, s3) 
    }
```

#### Errorf

`Errorf` 用于创建格式化的错误消息并返回一个 `error` 类型的值。这允许你将格式化的错误消息返回给调用者，以便更好地进行错误处理。这些函数的用法类似于 `Sprintf`，但它们返回一个 `error` 值而不是字符串。

- `Errorf`：根据`format`参数生成格式化字符串并返回一个包含该字符串的错误。

```go
func Errorf(format string, a ...interface{}) error
```

通常使用这种方式来自定义错误类型，例如：

```go
err := fmt.Errorf("这是一个错误")
```

### 格式化占位符

`*printf`系列函数都支持format格式化参数，在这里我们按照占位符将被替换的变量类型划分，方便查询和记忆。

#### 通用占位符

通用占位符用于格式化不同类型的数据：

| 占位符 | 说明 |
| --- | --- |
| %v | 值的默认格式表示 |
| %+v | 类似%v，但输出结构体时会添加字段名 |
| %#v | 值的Go语法表示 |
| %T | 打印值的类型 |
| %% | 百分号 |

代码示例：

```go
func main() { 
    fmt.Printf("%v\n", 100) 
    fmt.Printf("%v\n", false) 
    o := struct{ name string }{"jarvis"} 
    fmt.Printf("%v\n", o) 
    fmt.Printf("%#v\n", o) 
    fmt.Printf("%T\n", o) 
    fmt.Printf("100%%\n") }
```

#### 布尔型

| 占位符 | 说明 |
| --- | --- |
| %t | true或false |

#### 整型

| 占位符 | 说明 |
| --- | --- |
| %b | 表示为二进制 |
| %c | 该值对应的unicode码值 |
| %d | 表示为十进制 |
| %o | 表示为八进制 |
| %x | 表示为十六进制，使用a-f |
| %X | 表示为十六进制，使用A-F |
| %U | 表示为Unicode格式：U+1234，等价于"U+%04X" |
| %q | 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示 |

示例代码如下：

```go
n := 65 
fmt.Printf("%b\n", n) 
fmt.Printf("%c\n", n) 
fmt.Printf("%d\n", n) 
fmt.Printf("%o\n", n) 
fmt.Printf("%x\n", n) 
fmt.Printf("%X\n", n)
```

#### 浮点数与复数

| 占位符 | 说明 |
| --- | --- |
| %b | 无小数部分、二进制指数的科学计数法，如-123456p-78 |
| %e | 科学计数法，如-1234.456e+78 |
| %E | 科学计数法，如-1234.456E+78 |
| %f | 有小数部分但无指数部分，如123.456 |
| %F | 等价于%f |
| %g | 根据实际情况采用%e或%f格式（以获得更简洁、准确的输出） |
| %G | 根据实际情况采用%E或%F格式（以获得更简洁、准确的输出） |

示例代码如下：

```go
f := 12.34 
fmt.Printf("%b\n", f) 
fmt.Printf("%e\n", f) 
fmt.Printf("%E\n", f) 
fmt.Printf("%f\n", f) 
fmt.Printf("%g\n", f) 
fmt.Printf("%G\n", f)
```

#### 字符串和\[\]byte

| 占位符 | 说明 |
| --- | --- |
| %s | 直接输出字符串或者\[\]byte |
| %q | 该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示 |
| %x | 每个字节用两字符十六进制数表示（使用a-f |
| %X | 每个字节用两字符十六进制数表示（使用A-F） |

示例代码如下：

```go
s := "jarvis" 
fmt.Printf("%s\n", s) 
fmt.Printf("%q\n", s) 
fmt.Printf("%x\n", s) 
fmt.Printf("%X\n", s)
```

#### 指针

| 占位符 | 说明 |
| --- | --- |
| %p | 表示为十六进制，并加上前导的0x |

示例代码如下：

```go
a := 18 
fmt.Printf("%p\n", &a) 
fmt.Printf("%#p\n", &a)
```

#### 宽度标识符

宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下

| 占位符 | 说明 |
| --- | --- |
| %f | 默认宽度，默认精度 |
| %9f | 宽度9，默认精度 |
| %.2f | 默认宽度，精度2 |
| %9.2f | 宽度9，精度2 |
| %9.f | 宽度9，精度0 |

示例代码如下：

```go
n := 88.88 
fmt.Printf("%f\n", n) 
fmt.Printf("%9f\n", n) 
fmt.Printf("%.2f\n", n) 
fmt.Printf("%9.2f\n", n) 
fmt.Printf("%9.f\n", n)
```

#### 其他flag

| 占位符 | 说明 |
| --- | --- |
| ‘+’ | 总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）； |
| ’ ' | 对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格 |
| ‘-’ | 在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）； |
| ‘#’ | 八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值； |
| ‘0’ | 使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面； |

举个例子：

```go
 s := 123
 fmt.Printf("8%d8\n", s)
 fmt.Printf("8%5d8\n", s)
 fmt.Printf("8%-5d8\n", s)
 fmt.Printf("8%5.4d8\n", s)
 fmt.Printf("8%05d8\n", s)
 fmt.Printf("8%+d8\n", -s)

 s1 := 123.45
 fmt.Printf("8%f8\n", s1)
 fmt.Printf("8%.2f8\n", s1)
 fmt.Printf("8%15f8\n", s1)
 fmt.Printf("8%15.2f8\n", s1)
 fmt.Printf("8%015.2f8\n", s1)

 

 s2 := "abc"
 fmt.Printf("8%08s8\n", s2)
 fmt.Printf("8% x8\n", s2)
```

### 获取输入

Go 语言的 `fmt` 包提供了 `fmt.Scan`、`fmt.Scanf` 和 `fmt.Scanln` 这三个函数，用于从标准输入获取用户的输入。这些函数允许你与用户交互，从标准输入流中读取不同类型的数据并将其存储在相应的变量中

#### Scan

`Scan` 函数用于从标准输入中获取用户的输入，并将输入的数据存储在变量中。它根据空格分隔输入，适合获取多个输入值。

函数定义如下：

```go
func Scan(a ...interface{}) (n int, err error)
```

- Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。
- 本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。

具体代码示例如下：

```go
package main
import "fmt"
func main() { 
    var name string 
    var age int
    fmt.Print("Enter your name: ") 
    fmt.Scan(&name) 
    fmt.Print("Enter your age: ") 
    fmt.Scan(&age)
    fmt.Printf("Name: %s, Age: %d\n", name, age) 
    }
```

#### Scanln(未理解)

`Scanln` 函数用于从标准输入中获取用户的输入，并将输入的数据存储在变量中，每行一个变量。它通常用于获取多个输入值，每个值在单独的行中输入。

函数定义如下：

```go
func Scanln(a ...interface{}) (n int, err error)
```

- Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。
- 本函数返回成功扫描的数据个数和遇到的任何错误。

#### Scanf

`Scanf` 函数用于根据格式规范解析输入，并将数据存储在变量中。它允许你指定输入的格式，并可以处理不同类型的数据。

函数签名如下：

```go
func Scanf(format string, a ...interface{}) (n int, err error)
```

- Scanf从标准输入扫描文本，根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。
- 本函数返回成功扫描的数据个数和遇到的任何错误。

代码示例如下：

```go
package main
import "fmt"
func main() { 
    var name string 
    var age int
    fmt.Print("Enter your name and age: ") 
    fmt.Scanf("%s %d", &name, &age)
    fmt.Printf("Name: %s, Age: %d\n", name, age) }
```

#### 使用 bufio 包获取输入

`bufio` 包提供了一种更灵活的方式来处理输入，特别是在需要完整读取一行或多行输入的情况下。你可以使用 `bufio.NewReader` 创建一个输入缓冲区，然后使用 `ReadString` 函数来读取输入，直到指定的分隔符（例如换行符 `\n`）。这允许你获取包含空格在内的完整输入内容。

```go
func bufioDemo() { 
    reader := bufio.NewReader(os.Stdin) // 从标准输入生成读对象 
    fmt.Print("请输入内容：") 
    text, _ := reader.ReadString('\n') // 读取直到换行符 
    text = strings.TrimSpace(text) 
    fmt.Printf("%#v\n", text) 
    }
```

#### 使用 Fscan 函数

`Fscan` 系列函数允许你从 `io.Reader` 接口中读取数据，而不仅仅是标准输入。这些函数与 `fmt.Scan`、`fmt.Scanf` 和 `fmt.Scanln` 类似，但允许你从任何实现 `io.Reader` 接口的地方读取数据。

- `Fscan`：从 `io.Reader` 中读取数据。
- `Fscanln`：从 `io.Reader` 中读取一行数据。
- `Fscanf`：根据指定的格式从 `io.Reader` 中读取数据。

```go
func Fscan(r io.Reader, a ...interface{}) (n int, err error) 
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
```

代码示例：

```go
package main
import ( "fmt" "strings" )
func main() { 
    input := "42 John" 
    reader := strings.NewReader(input) // 从字符串生成读对象
    var age int 
    var name string
    n, err := fmt.Fscanf(reader, "%d %s", &age, &name) 
    if err != nil { 
        fmt.Println("Error:", err) 
        return 
        }
    fmt.Printf("Read %d values: Age: %d, Name: %s\n", n, age, name) 
    }
```

#### 使用 Sscan 函数

`Sscan` 系列函数允许你从字符串中读取数据，而不仅仅是从标准输入。这些函数与 `fmt.Scan`、`fmt.Scanf` 和 `fmt.Scanln` 类似，但允许你从字符串中读取数据。

```go
func Sscan(str string, a ...interface{}) (n int, err error) 
func Sscanln(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
```

代码示例：

```go
package main
import ( "fmt" )
func main() { 
    input := "Alice 30" 
    var name string 
    var age int
    n, err := fmt.Sscanf(input, "%s %d", &name, &age) 
    if err != nil { 
        fmt.Println("Error:", err) 
        return 
        }
    fmt.Printf("Read %d values: Name: %s, Age: %d\n", n, name, age) }
```

## io

io 包提供了许多用于处理 I/O（输入输出） 操作的接口和函数。

### Reader

io.Reader 表示任何可以读取数据的对象，定义了基本的 Read 方法。

```go
type Reader interface { Read(p []byte) (n int, err error) }
```

Read 方法读取长度为 len(p) 字节的数据到 p 中，返回两个参数，读取数据的字节数（0 <= n <= len(p)）和 error 信息。当 Read 在读取 n>0 个字节后遇到错误或 EOF 时，返回读取的字节数和一个可能为非空的 error，下次接着读取时，会返回 0 和 非空 error。看个示例：

```go
package main

import (
 "fmt"
 "io"
 "os"
)

func main() {
 f, err := os.Open("test.txt")
 if err != nil {
  panic(err)
 }
 defer f.Close()
 buf := make([]byte, 4) // 实例化一个长度为4的[]byte
 i := 0
 for {
  i++
  n, err := f.Read(buf)
  fmt.Printf("第 %d 次读取, ", i)
  fmt.Printf("返回行数：%d，error 信息：%v ", n, err)
  if n == 0 || err == io.EOF {
   fmt.Println("文件以读取完毕")
   break
  }
  fmt.Printf("读取内容：%s \n", string(buf[:n]))
 }
}

```

将 test.txt 文件内容设置为 5 个字节 luduoe\nqwe，运行看下效果：

```go
第 1 次读取, 返回行数：4，error 信息：<nil> 读取内容：ludu 
第 2 次读取, 返回行数：4，error 信息：<nil> 读取内容：oe

第 3 次读取, 返回行数：3，error 信息：<nil> 读取内容：qwe
第 3 次读取, 返回行数：0，error 信息：EOF 文件以读取完毕
```

## io.Writer

Writer 接口表示一个可以写入数据的对象，定义了基本的 Write 方法。

```go
type Writer interface { Write(p []byte) (n int, err error) }
```

Write方法写入长度为 len(p) 字节的数据到基本数据流中，返回实际写入的字节数 n 和 error 信息。若 Write 返回的 n < len(p)，同时会返回一个非 nil 的 error。简单示例如下：

```go
package main 
import ( 
    "fmt" 
    "os" 
) 
func main() { 
    file, err := os.Create("file.txt") 
    if err != nil { 
        panic(err) 
        } 
        defer file.Close() 
        data := []byte("luduoxin's blog") 
        n, err := file.Write(data) 
        if err != nil { 
            panic(err) 
        } 
        fmt.Printf("%d bytes written", n) 
        }
```

## io.Closer

Closer 接口表示可以关闭的对象，定义了一个基本的 Close 方法，通常在完成读写后关闭IO流以释放资源。

```go
type Closer interface { Close() error }
```

Close 方法用于释放资源，返回可能出现的 error，简单示例如下：

```go
import ( 
    "os" 
) 
func main() { 
    file, err := os.Create("file.txt") 
    if err != nil { 
        panic(err) 
    } // 在文件使用结束后，需要调用 Close 方法释放资源。 
    defer file.Close() // 文件读写操作... 
    }
```

## io.Seeker

Seeker 接口表示可以随机读写的对象，定义了基本的 Seek 方法。Seek方法定位到给定偏移量位置，返回新的 offset 和 error 信息。

```go
type Seeker interface { Seek(offset int64, whence int) (int64, error) }
```

Seek 方法将当前读或写位置设置为距离偏移量 offset 个字节之后的位置。参数 whence 可以是 0、1 或 2：

1. 参数 whence 为 0 时，表示相对于文件起始位置，offset 必须为非负数。
2. 参数 whence 为 1 时，表示相对于当前位置，offset 可以为负数。
3. 参数 whence 为 2 时，表示相对于文件结尾，offset 可以为负数。

Seek 方法将返回新的偏移量和可能出现的错误。示例如下：

```go
package main 
import ( 
    "fmt" 
    "io" 
    "os" 
) 
func main() { 
    file, err := os.Create("file.txt") 
    if err != nil { 
        panic(err) 
        } 
    defer file.Close() // 写入数据到文件中... 
    file.Write([]byte("hello world")) // 将文件指针移动到文件头 
    file.Seek(0, io.SeekStart) // 从文件中读取数据到切片中 
    buf := make([]byte, 5) 
    file.Read(buf) 
    fmt.Println(string(buf)) // 输出 hello // 将文件指针移动文件末尾 
    file.Seek(0, io.SeekEnd) // 在文件末尾进行写入操作 
    file.Write([]byte("golang")) }
```

通过调用 Seek 方法将文件指针移动到文件开头，并从文件中读取了数据，接下来将文件指针移动到文件末尾，并在文件末尾写入了新的数据。

## os

| 函数 | 功能 | 备注 |
|------|------|------|
| `Chdir(dir string) error` | 将当前工作目录更改为指定目录。 | |
| `Chmod(name string, mode FileMode) error` | 将指定文件的权限模式更改为给定的模式。 | |
| `Chown(name string, uid, gid int) error` | 更改指定文件的所有者和组。 | 仅在支持的平台上可用（如Unix系统） |
| `Chtimes(name string, atime time.Time, mtime time.Time) error` | 更改指定文件的访问时间和修改时间。 | |
| `Create(name string) (*File, error)` | 创建一个新文件或截断现有文件。 | |
| `Exit(code int)` | 以给定的状态码退出当前程序。 | 通常用于错误处理 |
| `Expand(s string, mapping func(string) string) string` | 根据提供的映射函数在字符串中扩展环境变量。 | |
| `Getegid() int` | 获取调用者的有效组ID。 | |
| `Getenv(key string) string` | 获取环境变量的值。 | |
| `Geteuid() int` | 获取调用者的有效用户ID。 | |
| `Getgid() int` | 获取调用者的组ID。 | |
| `Getgroups() ([]int, error)` | 获取调用者所属的附加组ID列表。 | |
| `Getpagesize() int` | 获取系统内存页大小。 | |
| `Getpid() int` | 获取调用者的进程ID。 | |
| `Getppid() int` | 获取调用者的父进程ID。 | |
| `Getuid() int` | 获取调用者的用户ID。 | |
| `Hostname() (name string, err error)` | 获取内核报告的主机名。 | |
| `IsExist(err error) bool` | 报告错误是否表明文件或目录已存在。 | |
| `IsNotExist(err error) bool` | 报告错误是否表明文件或目录不存在。 | |
| `IsPermission(err error) bool` | 报告错误是否表明权限被拒绝。 | |
| `Link(oldname, newname string) error` | 创建一个硬链接将newname链接到oldname文件。 | |
| `Mkdir(name string, perm FileMode) error` | 创建一个新目录，具有指定的名称和权限位。 | |
| `MkdirAll` | 递归地创建目录及其父目录。 | |
| `MkdirAll(name string, perm FileMode) error` | 递归地创建目录及其父目录，具有指定的名称和权限位。 | |
| `NewFile(fd uintptr, name string) *File` | 使用指定的文件描述符和名称创建新的文件。 | |
| `Open(name string) (*File, error)` | 打开指定名称的文件。 | |
| `OpenFile(name string, flag int, perm FileMode) (*File, error)` | 根据指定的标志和权限位打开或创建文件。 | |
| `Pipe() (r *File, w *File, err error)` | 创建一个同步的管道，返回相应的读取器和写入器。 | |
| `Read(b []byte) (n int, err error)` | 从文件或文件描述符读取数据。 | |
| `ReadDir(dirname string) ([]os.FileInfo, error)` | 读取目录的内容。 | |
| `ReadFile(filename string) ([]byte, error)` | 读取整个文件的内容。 | |
| `Readlink(name string) (string, error)` | 读取符号链接的目标。 | |
| `Remove(name string) error` | 删除指定的文件或目录。 | |
| `RemoveAll(path string) error` | 递归地删除指定的目录及其所有内容。 | |
| `Rename(oldpath, newpath string) error` | 将文件或目录从一个名称更改为另一个名称。 | |
| `SameFile(fi1, fi2 os.FileInfo) bool` | 报告两个文件是否指向同一文件。 | |
| `Setenv(key, value string) error` | 设置环境变量的值。 | |
| `Symlink(oldname, newname string) error` | 创建符号链接。 | |
| `TempDir() string` | 返回用于临时文件的默认目录。 | |
| `Truncate(name string, size int64) error` | 将指定文件截断为指定大小。 | |
| `Unsetenv(key string) error` | 删除指定的环境变量。 | |
| `Write(b []byte) (n int, err error)` | 向文件或文件描述符写入数据。 | |
| `WriteFile(filename string, data []byte, perm os.FileMode) error` | 将数据写入指定的文件。 | |
